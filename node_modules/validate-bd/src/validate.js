// validate is the automated way
// to keep your json or model attributes valid.

// Instructions
// --------------

// To make a field mandatory set it equal to [] or set your rules instead

//     var validations = { name: [] }

//     var validations = { name: [ [v8n().fullname(), 'Enter your fullname'] ] }

// To make a field not mandatory you can either no list it in your stack of field validations of set it to false

//     var validations = { name: false }

// Advanced topics:

// 1. You can also send a function for validations so you can define your rules according to values received

// 2. On rule array you can send a third value that is called 'getValue'.
// That will be a function responsible for return a value to be validated for that field

//     var validations = { name: [ [v8n().fullname(), 'Enter your fullname', ()=>{ return 'any other variable'; }] ] }

// 3. If you want to test a value received in realtime from user input set validateAll to false

//     vl.validate({ name: 'boldhouse' }, {validateAll: false})

// 4. Complex objects works well too.

//     var json = {name: 'boldhouse', contacts: [ {email: 'team@boldhouse.org'} , {email: 'admin@boldhouse.org'} ]};
//     var validations = {name: [], 'contacts[][email]': []};
//     vl.validate(json, {validations})

// Examples
// --------------

//     - simple validation
//     var validations = { name: [ [v8n().fullname(), 'Enter your fullname'] ] }
//     var json = { name: 'bruno' }
//     var r;
//     if((r = vl.validate(json, {validations}))!==null) {
//          console.log(r);
//     }

//     - making a field just mandatory
//     var validations = { name: [] }
//     var json = { name: 'bruno' }
//     var r;
//     if((r = vl.validate(json, {validations}))!==null) {
//          console.log(r);
//     }

// CODE DOCUMENTED BELOW
// --------------

// --------------

// Baseline setup
// --------------
import _ from 'lodash';
import validators from './validators.js';

var deepValueSearch = function (path, attrs, defaultValue) {
    var value = defaultValue;
    var pathArray = path.split(/\.\./g);

    if (pathArray.length === 2) {
        value = [];
        _.each(pathArray, (path) => {
            if (attrs) {

                if (_.isArray(attrs)) {
                    return _.each(attrs, (attr, x) => {
                        var pos = parseInt(x, 10) + 1,
                            last = attrs.length === pos;

                        if (typeof attr === 'undefined') { return value.push(SyntaxError); }
                        let valueFound = deepValueSearch(path, attr);

                        if (typeof valueFound !== 'undefined' || last) { value.push(valueFound); }
                    });
                }
                attrs = deepValueSearch(path, attrs);

            }
        })
    } else {
        pathArray = path.split(/\./g);
        let valueFound = _.cloneDeep(attrs);
        _.each(pathArray, (path) => {
            try {
                valueFound = valueFound[path];
            } catch (e) {
                valueFound = undefined;
            }
        });

        if (typeof valueFound !== 'undefined') { value = valueFound; }
    }

    return value;
};

var vl = {
    validators,
    validator: () => [validator, config],
    _validator(returnId = false) {
        return this.validator()[!returnId ? 0 : 1];
    },
    deepValueSearch,
    validateAll: true,
    // replacement for core method
    _validate(attrs, options) {
        if (!options.validate || !this.validate) {
            return true;
        }

        /* this line was causing trouble when changing model validations for existent rows (because rows would be invalid if some validations became necessary after the row was already stored)
        attrs = _.extend({}, this.attributes, attrs); */
        attrs = _.extend({}, attrs);

        var error = (this.validationError =
            this.validate(attrs, options) || null);
        if (!error) {
            return true;
        }

        this.trigger(
            'invalid',
            this,
            error,
            _.extend(options, { validationError: error })
        );
        return false;
    },
    // Core method the walk through fields and their set of rules applying each one of them
    validate(attrs, options = {}) {
        options = _.defaults(options, {
            validateAll: this.validateAll,
        });

        var error = [],
            validations = this.getValidations(attrs, options),
            notEmptyValidation = this.nonEmptyValidation(),
            isRequired = {};

        // walk through fields listed as required
        for (let field in validations) {
            isRequired[field] = true;
            let value = this.deepValueSearch(field, attrs);
            let errorMessage;

            // working with array so we can validate lists like 'contacts[][email]'
            ((!_.isArray(value) && !_.isPlainObject(value)) ||
                (!/\.\.\w+/.test(field) && _.isArray(value))) && // ensure to pass the correct value to test length of lists
                (value = [value]);
            !_.isArray(validations[field]) &&
                (validations[field] = [validations[field]]);

            // walk through field rule specifications
            for (let x in validations[field]) {
                let validation = validations[field][x];

                if (!parseInt(x, 10) && typeof validation === 'string') {
                    errorMessage = validation;
                    continue;
                } else if (!_.isArray(validation)) {
                    validation = [validation, errorMessage || this.getRequiredErrorMessage(field)];
                }

                if (
                    typeof validation[0] === 'boolean' ||
                    typeof validation[0] === 'undefined'
                ) {
                    isRequired[field] = validation !== false;
                    if (!isRequired[field]) {
                        continue;
                    }
                    // if is required, set default validation and error message for it
                    validation = [
                        notEmptyValidation,
                        validation[1] || errorMessage || this.getRequiredErrorMessage(field),
                        validation[2] || null,
                    ];
                }

                error = error.concat(
                    this.validateValues(
                        value,
                        isRequired[field],
                        options.validateAll,
                        field,
                        attrs,
                        validation
                    )
                );
            }
        }

        return error.length > 0 ? error : null;
    },
    nonEmptyValidation() {
        return this._validator(true).nonEmptyValidation(this._validator());
    },
    validateValues(value, isRequired, validateAll, field, attrs, validation) {
        var error = [];
        for (var x in value) {
            if (value[x] === SyntaxError) { continue; }
            error = error.concat(
                this.validateValue(
                    x,
                    value[x],
                    isRequired,
                    validateAll,
                    field,
                    attrs,
                    validation
                )
            );
        }

        return error;
    },
    validateValue(x, value, isRequired, validateAll, field, attrs, validation) {
        var error = [];
        let validationValue = this.getValidationValue(
            validation,
            value,
            attrs,
            field
        );
        if (
            this.isRequiredNow(validationValue, isRequired, validateAll) &&
            !this.isValid(field, attrs, validation[0], validationValue)
        ) {
            error.push([field, validation[1], x]);
        }

        return error;
    },
    getValidationValue(validation, value, attrs, field) {
        if (!validation[2] || typeof validation[2] !== 'function') {
            return value;
        }

        var allAttrs = _.extend({}, this.attributes, attrs);
        return validation[2](value, allAttrs, field);
    },
    getValidations(attrs, options = {}) {
        var definedValidations = (typeof this.validations === 'function' ? this.validations(attrs, options) : this.validations) || {},
            validations = (typeof options.validations === 'function' ? _.bind(options.validations, this)(attrs, options) : options.validations) || definedValidations;

        return validations;
    },
    // Run through all validations to collect mandatory fields and validations
    getMandatoryValidations(attrs, options = {}) {
        var validations = this.getValidations(attrs, options),
            mandatory = {};

        // walk through fields listed as required
        for (let field in validations) {
            !_.isArray(validations[field]) &&
                (validations[field] = [validations[field]]);
            // walk through field rule specifications
            for (let x in validations[field]) {
                let validation = validations[field][x];
                if (
                    typeof validation[0] === 'undefined' ||
                    (typeof validation[0] === 'boolean' &&
                        validation[0] !== false) ||
                    (typeof validation[0] === 'object' &&
                        !validation[0].test(''))
                ) {
                    !(field in mandatory) && (mandatory[field] = []);
                    mandatory[field].push(validation);
                }
            }
        }

        return mandatory;
    },
    // A field will be required when its present in the set of rules - even if its value is an empty [] -
    // AND (its present in the values received OR (its set as required and validate all was set true)) .
    // A bit confusing I know. But this will allow you to run validate in your form everytime a field is changed avoiding
    // to alert of invalid fields that yet weren't filled by the guest
    isRequiredNow(input, fieldRequired = false, validateAll) {
        // the field will be required only if its value was sent or if its set as required (even without a specific rule)
        return (
            typeof input !== 'undefined' || (!!fieldRequired && !!validateAll)
        );
    },
    // Apply the rule test to value received. value, attrs inputted and field name are sent to validation method - it can be handy.
    isValid(field, attrs, validation, value) {
        // test for v8n, validate for foi
        return this._validator(true).isValid(validation, value, field, attrs);
    },
    requiredErrorMessage: 'Field *{{field}}* cannot be empty',
    getRequiredErrorMessage(field) {
        return _.template(this.requiredErrorMessage)({
            field,
        });
    },
    validatorDetection(compare) {
        return this._validator(true).id === compare;
    }
};

export default vl;
